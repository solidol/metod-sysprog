\chapter{Рекурсія}
\nopagebreak[4]
\section*{Мета роботи}

\nopagebreak[4]
\section{Вступ}
\nopagebreak[4]
У математиці для вирішення переважної більшості завдань використовуються методи, які в кінцевому рахунку можуть бути зведені до одного з двох базових способів: ітерації або рекурсії.


\textbf{Ітерація} означає кількаразове повторення одних і тих же дій, яке після деякої кількості кроків приводить до бажаного результату. Характерним прикладом ітераційного способу вирішення завдання є методи послідовних наближень рішення нелінійних рівнянь, у тому числі метод дотичних, метод хорд і т.д.

\begin{equation}
f(x)=0; x=\varphi(x); x_0=a; x_n=\varphi(x_{n-1}), n=1,2,..., |x_k-x_{k-1}|>\epsilon
\end{equation}

\textbf{Рекурсія} являє собою посилання при описі об'єкта, дії на описуваний об'єкт, дія. Рекурсія означає рішення задачі за допомогою відомості рішення до самого себе. При цьому обчислення залежать від інших, в не-якому сенсі більш простих (зазвичай менших) значень аргументу або аргументів завдання. Повністю аналогічні механізми використовуються в базовій теорії рекурсивних функцій, у методі математичної індукції, а також в рекурентних послідовностях. 

Наприклад:

\begin{equation}
a_k = 2a_{k-1} + k , \forall k > 0, a_0 = 1
\end{equation}

\textbf{Рекурсивний алгоритм} - це алгоритм, в описі якого прямо або побічно міститься звернення до самого себе. У техніці процедурного програмування дане поняття поширюється на функцію, яка реалізує рішення окремого блоку завдання за допомогою виклику зі свого тіла інших функцій, в тому числі і себе самої. Якщо при цьому на черговому етапі роботи функція організовує звернення до самої себе, то така функція є рекурсивної.



\section{Ключові терміни}
\nopagebreak[4]


\textbf{База рекурсії} - це тривіальний випадок, при якому рішення задачі очевидно, тобто не потрібно звернення функції до себе.

\textbf{Глибина рекурсивних викликів} - це найбільше одночасне кількість рекурсивних звернень функції, визначальне максимальну кількість шарів рекурсивного стека.

\textbf{Декомпозиція} - це вираження загального випадку через більш прості підзадачі зі зміненими параметрами.

\textbf{Корінь повного дерева рекурсивних викликів} - це вершина повного дерева рекурсії, відповідна початкового зверненням до функції.

\textbf{Непряма (взаємна) рекурсія} - це послідовність взаємних викликів декількох функцій, організована у вигляді циклічного замикання на тіло первісної функції, але з іншим набором параметрів.

\textbf{Обсяг рекурсії} - це характеристика складності рекурсивних обчислень для конкретного набору параметрів, що представляє собою кількість вершин повного рекурсивного дерева без одиниці.

\textbf{Параметризація} - це виділення з постановки задачі параметрів, які використовуються для опису умови задачі і рішення.

\textbf{Повне дерево рекурсії} - це граф, вершинами якого є набори фактичних параметрів при всіх викликах функції, починаючи з першого звернення до неї, а ребрами - пари таких наборів, відповідних взаємним викликам.

\textbf{Пряма рекурсія} - це безпосереднє звернення рекурсивної функції до себе, але з іншим набором вхідних даних.

\textbf{Рекурсивна тріада} - це етапи вирішення завдань рекурсивним методом.

\textbf{Рекурсивна функція} - це функція, яка у своєму тілі містить звернення до самої себе зі зміненим набором параметрів.

\textbf{Рекурсивний алгоритм} - це алгоритм, у визначенні якого міститься прямий або непрямий виклик цього ж алгоритму.

\textbf{Рекурсія} - це визначення об'єкта за допомогою посилання на себе.


\section{Розширені теоретичні відомості}
\nopagebreak[4]


Рекурсивні алгоритми зазвичай виходять на основі математичної постановки завдання. Найважливіше при побудові рекурсивного алгоритму: побачити однакові дії на поточному та попередньому кроці обчислень (дій).

Виконавець рекурсивного алгоритму зводить невідоме до іншого невідомого, накопичуючи інформацію (прямий хід) і відкладаючи фактичні обчислення до моменту, коли виконається умова, що дозволяють безпосередньо обчислити шукане значення. Потім виконується зворотний хід рекурсії.

\textbf{Основні переваги рекурсії:}
\begin{itemize}
\item простота математичного формулювання;
\item простота алгоритму і його реалізації
\end{itemize}
\textbf{Основні недоліки рекурсії:}
\begin{itemize}
\item додаткові витрати оперативної пам'яті;
\item додаткові тимчасові витрати;
\item можливий перехід складності в клас EXP.
\end{itemize}

За аналогією з математичної індукцією, на яку рекурсія трохи схожа, будь рекурсивна процедура повинна включати в себе базис і крок рекурсії.

Базис рекурсії - це пропозиція, що визначає якусь початкову ситуацію або ситуацію в момент припинення. Як правило, в цій пропозиції записується якийсь найпростіший випадок, при якому відповідь виходить відразу навіть без використання рекурсії. Так, у наведеній вище процедурі, яка описує предикат предок, базисом рекурсії є перше правило, в якому визначено, що найближчими предками людини є його батьки. Ця пропозиція часто містить умову, при виконанні якї відбувається вихід з рекурсії або відсікання.

Крок рекурсії - це правило, в тілі якого обов'язково міститься, в якості підцілі, виклик обумовленого предиката. Якщо ми хочемо уникнути зациклення, який визначається предикат повинен викликатися не вiд тих же параметрів, які вказані в заголовку правила. Параметри повинні змінюватися на кожному кроці так, щоб в результаті або спрацював базис рекурсії, або умова виходу з рекурсії, розміщене в самому правилі.

\section{Приклади обчислень}
\nopagebreak[4]


\subsection*{Приклад 1. Обчислення факторіала $P=n!$, n - ціле число}

Зазвичай для обчислення факторіала цілого числа використовується ітераційний спосіб, заснований на багаторазовому домноженні величини, в якій накопичується результат, на черговий співмножник: 

\begin{equation}
Pi := P_{i-1} \times i, i=2,3,...,k.  
\end{equation}

\begin{lstlisting}[label=iter1,caption=Ітераційна функція] 
function factorial (k:integer):integer;
	var P,i:integer;  { i – номер сомножителя, P – накапливаемый результат}
begin
	P:=1;
	for i:=1 to k do
		P:=P*i;
	factorial:=P;
end;
\end{lstlisting}

Це завдання можна вирішити і за допомогою рекурсії, базуючись на наступних міркуваннях:

\begin{equation}
k! = 1 \times 2 \times 3 \times \dots \times k =  1 \times 2 \times 3 \times \dots \times (k-1) \times k = (k-1)! \times k
\end{equation}

Отже, $P(k) = k!$ можна визначити таким чином:

\begin{equation}
P(k) = 
 \begin{cases}
   1,k=1\\
   P(k-1)\times k,k>1
 \end{cases}
\end{equation}

\begin{lstlisting}[label=iter1,caption=Рекурентна функція] 
function factorial1 (k:integer):integer ;
begin
	if k=1 then factorial1:=1 
		else  factorial1:= factorial1(k-1)*k
end;
\end{lstlisting}




\section{Індивідуальне завдання}
\nopagebreak[4]
\subsection*{Завдання до лабораторної роботи}
\nopagebreak[4]
\begin{enumerate}
\item Вивчити теоретичний матеріал
\item Відповісти на контрольні запитання
\item Скласти звіт
\item Захистити роботу
\end{enumerate}

\subsection*{Контрольні запитання}
\nopagebreak[4]
\begin{enumerate}
\item Що таке Internet? З яких структурних частин складається Internet?
\item Що таке IP-адреса?
\item Що таке доменне ім'я, з чого воно складається?
\item Який сервіс Internet перетворює IP-адреси в доменні імена і навпаки?
\item Яка служба займається розподіленням блоків IP-адрес?
\item Протокол HTTP. Рівень у моделі OSI, призначення.
\item Значення URI, URL, URN.
\item Мови web-програмування, які ви знаєте.
\item Веб-сервери, які ви знаєте.
\item Мережеві СКБД, які ви знаєте. 
\end{enumerate}



